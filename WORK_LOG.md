Name: YOUR NAME HERE

| Date   |     Time      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Update |
|:-------|:-------------:|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Sep 24 |  9:05-9:35am  | I spent this time discussing pseudocode with Liam, Sierra, and Clifford. Together, we came up with the idea of sorting the dictionary into a tree, in order to have constant time lookups. We wanted to do this by having 26 spanning trees, one representing each letter of the alphabet, and each having 26 children if necessary, one representing each next letter in the alphabet. As a word comes up in the dictionary, we will go to the corresponding location in the tree which represents that word, and if that location doesn't exist, creating it. |
| Sep 24 |  6:00-6:30pm  |                                                                            I spent most of this time actually writing out the pseudocode for the organizing of the dictionary (I actually never coded this way but I figured since it's such a complex problem, it could be worthwhile.). I said to loop through each word in the dictionary, and then loop through each letter, going to the location in the tree where that prefix exists and if that prefix doesn't exist, creating a new array of 26 prefix objects in order to create it. Next up, coding! |
| Sep 25 | 8:00am-8:30am |                                                                                                                                                                                                  I spent this time actually coding the organizeDictionary function and began coding the actual checking of each word as well. I decided to use an Object prefix, which keeps track of whether or not it is a word, as well as all of its children in an array of Prefixes. My next step is to continue coding out the actual checking of each word in the text. |
| Sep 25 | 2:00pm-2:30pm |                                                                                                                                     I spent this time actually coding out my functions for checking each word. I am using a isDuplicate function, checking the word against each of the misspelled words I've already added, as well as checkMispelled(), checking if a word is actually misspelled, as well as indexShift() which shifts the character to its corresponding location in the alphabet 0-25, with the exception of apostraphe being at index 26. |
| Sep 25 | 2:30pm-3:00pm |                                                                                                                       I finished coding out each of my methods and got something working! I am now beginning to think about improving efficiency, one thing I was thinking about was how I have to do a lookup search for each prefix from the root, but if the dictionary is sorted, I should be able to start halfway down the tree to go to the leaf of the next word (since I am following the same path). However, haven't figured out how to do that yet. |


To add a new row to the table, click into a cell and then hit shift-enter.